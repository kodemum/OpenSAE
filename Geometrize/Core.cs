// Generated by Haxe 4.3.1

#pragma warning disable 109, 114, 219, 429, 168, 162

using Geometrize.Rasterizer;
using Geometrize.Shape;
using SixLabors.ImageSharp.PixelFormats;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace Geometrize
{
    internal static class Core
    {
        public static Rgba32 ComputeColor(Bitmap target, Bitmap current, IEnumerable<Scanline> lines, int alpha)
        {
            unchecked
            {
                if (target == null)
                {
                    throw new Exception("FAIL: target != null");
                }

                if (current == null)
                {
                    throw new Exception("FAIL: current != null");
                }

                if (lines == null)
                {
                    throw new Exception("FAIL: lines != null");
                }

                if (alpha < 0)
                {
                    throw new Exception("FAIL: alpha >= 0");
                }

                long totalRed = 0;
                long totalGreen = 0;
                long totalBlue = 0;
                int count = 0;
                int a = (int)(65535d / alpha);

                Dictionary<Rgba32, int> counts = new();

                foreach (var line in lines)
                {
                    int y = line.y;

                    for (int x = line.x1; x < line.x2 + 1; x++)
                    {
                        var t = target.data[(target.width * y) + x];
                        var c = current.data[(current.width * y) + x];
                        totalRed += ((t.R - c.R) * a) + (c.R * 257);
                        totalGreen += ((t.G - c.G) * a) + (c.G * 257);
                        totalBlue += ((t.B - c.B) * a) + (c.B * 257);
                        ++count;

                        if (counts.TryGetValue(t, out int tc))
                        {
                            counts[t] = tc + 1;
                        }
                        else
                        {
                            counts[t] = 1;
                        }
                    }
                }

                if (count == 0)
                {
                    return new Rgba32(0, 0, 0, 0);
                }

                var maxColor = counts.OrderByDescending(x => x.Value).First();
                double averageColorCount = counts.Average(x => x.Value);

                if (maxColor.Value > averageColorCount * 15)
                {
                    return new Rgba32(maxColor.Key.R, maxColor.Key.G, maxColor.Key.B, 255);
                }
                else
                {
                    byte r = (byte)((totalRed / count) >> 8);
                    byte g = (byte)((totalGreen / count) >> 8);
                    byte b = (byte)((totalBlue / count) >> 8);

                    return new Rgba32(r, g, b, (byte)alpha);
                }
            }
        }

        public static double DifferenceFull(Bitmap first, Bitmap second)
        {
            if (second.overlay != null)
                second += second.overlay;

            double total = 0;

            for (int y = 0; y < first.height; y++)
            {
                for (int x = 0; x < first.width; x++)
                {
                    var f = first.data[(first.width * y) + x];
                    var s = second.data[(second.width * y) + x];

                    int dr = f.R - s.R;
                    int dg = f.G - s.G;
                    int db = f.B - s.B;
                    int da = f.A - s.A;

                    total += (dr * dr) + (dg * dg) + (db * db) + (da * da);
                }
            }

            return Math.Sqrt(total / (first.width * first.height * 4.0)) / 255;
        }

        public static double DifferencePartial(Bitmap target, Bitmap before, Bitmap after, double score, IEnumerable<Scanline> lines)
        {
            unchecked
            {
                if (target == null)
                {
                    throw new Exception("FAIL: target != null");
                }

                if (before == null)
                {
                    throw new Exception("FAIL: before != null");
                }

                if (after == null)
                {
                    throw new Exception("FAIL: after != null");
                }

                if (lines == null)
                {
                    throw new Exception("FAIL: lines != null");
                }

                if (after.overlay != null)
                    after += after.overlay;

                int width = target.width;
                int height = target.height;
                int rgbaCount = width * height * 4;
                double total = System.Math.Pow(score * 255, 2) * rgbaCount;

                foreach (var line in lines)
                {
                    int y = line.y;
                    {
                        int _g1 = line.x1;
                        int _g2 = line.x2 + 1;
                        while (_g1 < _g2)
                        {
                            int x = _g1++;
                            var t = target.data[(target.width * y) + x];
                            var b = before.data[(before.width * y) + x];
                            var a = after.data[(after.width * y) + x];

                            int dtbr = t.R - b.R;
                            int dtbg = t.G - b.G;
                            int dtbb = t.B - b.B;
                            int dtba = t.A - b.A;
                            int dtar = t.R - a.R;
                            int dtag = t.G - a.G;
                            int dtab = t.B - a.B;
                            int dtaa = t.A - a.A;
                            total -= (dtbr * dtbr) + (dtbg * dtbg) + (dtbb * dtbb) + (dtba * dtba);
                            total += (dtar * dtar) + (dtag * dtag) + (dtab * dtab) + (dtaa * dtaa);
                        }
                    }
                }

                return System.Math.Sqrt(total / rgbaCount) / 255;
            }
        }

        public static State BestRandomState(int alpha, int n, Bitmap target, Bitmap current, Bitmap buffer, double lastScore, SymbolShapeOptions symbolOptions, System.Threading.CancellationToken token)
        {
            object lockObj = new object();

            double bestEnergy = 0;
            State bestState = null;

            ConcurrentBag<Bitmap> buffers = new ConcurrentBag<Bitmap>();

            Parallel.For(0, n, new ParallelOptions() { CancellationToken = token }, (i) =>
            {
                if (!buffers.TryTake(out Bitmap myBuffer))
                {
                    myBuffer = Bitmap.CreateTransparent(target.width, target.height);
                    myBuffer.overlay = buffer.overlay;
                }

                State state = new State(ShapeFactory.randomShapeOf(current.width, current.height, symbolOptions), alpha, target, current, myBuffer);
                double energy = state.energy(lastScore);

                lock (lockObj)
                {
                    if ((i == 0) || (energy < bestEnergy))
                    {
                        bestEnergy = energy;
                        bestState = state;
                    }
                }

                buffers.Add(myBuffer);
            });

            return bestState;
        }

        public static State BestHillClimbState(int alpha, int n, int age, Bitmap target, Bitmap current, Bitmap buffer, double lastScore, SymbolShapeOptions symbolOptions, System.Threading.CancellationToken token)
        {
            State state = BestRandomState(alpha, n, target, current, buffer, lastScore, symbolOptions, token);
            state = HillClimb(state, age, lastScore, token);
            return state;
        }

        public static State HillClimb(State state, int maxAge, double lastScore, System.Threading.CancellationToken token)
        {
            state = state.clone();
            State bestState = state.clone();
            double bestEnergy = state.energy(lastScore);

            int age = 0;

            while (age < maxAge)
            {
                State undo = state.mutate();
                double energy = state.energy(lastScore);
                if (energy >= bestEnergy || double.IsNaN(energy))
                {
                    state = undo;
                }
                else
                {
                    bestEnergy = energy;
                    bestState = state.clone();
                    age = -1;
                }

                age++;

                token.ThrowIfCancellationRequested();
            }

            return bestState;
        }

        public static double Energy(IShape shape, int alpha, Bitmap target, Bitmap current, Bitmap buffer, double score)
        {
            if (shape == null)
            {
                throw new Exception("FAIL: shape != null");
            }

            if (target == null)
            {
                throw new Exception("FAIL: target != null");
            }

            if (current == null)
            {
                throw new Exception("FAIL: current != null");
            }

            if (buffer == null)
            {
                throw new Exception("FAIL: buffer != null");
            }

            var lines = shape.Rasterize();
            if (lines.Count > 0)
            {
                var color = ComputeColor(target, current, lines, alpha);
                Rasterizer.Rasterizer.CopyLines(buffer, current, lines);
                Rasterizer.Rasterizer.DrawLines(buffer, color, lines);
            }
            return DifferencePartial(target, current, buffer, score, lines);
        }
    }
}
