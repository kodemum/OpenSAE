// Generated by Haxe 4.3.1

#pragma warning disable 109, 114, 219, 429, 168, 162
using System;
using System.Collections.Generic;

namespace Geometrize
{
    public class Bitmap
    {
        public static Bitmap CreateFromByteArray(int w, int h, IReadOnlyList<byte> bytes)
        {
            Bitmap bitmap = new Bitmap();

            if (bytes.Count != w * h * 4)
                throw new ArgumentException("Number of bytes must be equal to width * height * 4", nameof(bytes));

            bitmap.width = w;
            bitmap.height = h;
            bitmap.data = new int[bytes.Count / 4];

            int x = 0;
            for (int i = 0; i < bytes.Count; i += 4)
            {
                var red = bytes[i];
                var green = bytes[i + 1];
                var blue = bytes[i + 2];
                var alpha = bytes[i + 3];

                bitmap.data[x++] = (red << 24) + (green << 16) + (blue << 8) + alpha;
            }

            return bitmap;
        }

        public static Bitmap CreateFromSolidColor(int width, int height, int color)
        {
            Bitmap bitmap = new Bitmap
            {
                width = width,
                height = height,
                data = (new int[(width * height)])
            };

            if (color != 0)
                Array.Fill(bitmap.data, color);

            return bitmap;
        }

        public static Bitmap CreateTransparent(int width, int height)
            => CreateFromSolidColor(width, height, 0);


        public int width;

        public int height;

        public int[] data;

        public Bitmap overlay;

        public int GetPixel(int x, int y)
        {
            return data[width * y + x];
        }


        public void SetPixel(int x, int y, int color)
        {
            data[width * y + x] = color;
        }


        public Bitmap Clone()
        {
            Bitmap bitmap = new Bitmap
            {
                width = width,
                height = height,
                data = new int[data.Length]
            };

            Array.Copy(data, bitmap.data, data.Length);

            return bitmap;
        }

        public static Bitmap operator +(Bitmap left, Bitmap right)
        {
            if (left.height != right.height || left.width != right.width)
                throw new InvalidOperationException($"Bitmaps must be same size. left is {left.width}x{left.height}, right is {right.width}x{right.height}");

            var result = left.Clone();

            for (int y = 0; y < left.height; y++)
            {
                for (int x = 0; x < left.width; x++)
                {
                    var pos = y * left.width + x;

                    int leftPixel = left.data[pos];
                    int rightPixel = right.data[pos];

                    left.data[pos] = Add(leftPixel, rightPixel);
                }
            }

            return result;
        }

        public static int Add(int c, int d)
        {
            int sr = (c >> 24) & 255;
            sr |= sr << 8;
            sr *= c & 255;
            sr /= 255;

            int sg = (c >> 16) & 255;
            sg |= sg << 8;
            sg *= c & 255;
            sg /= 255;

            int sb = (c >> 8) & 255;
            sb |= sb << 8;
            sb *= c & 255;
            sb /= 255;

            int sa = c & 255;
            sa |= sa << 8;

            int ma = 65535;
            int m = 65535;
            int a = (int)(double)((m - (sa * (((double)ma) / m))) * 257);

            int dr = (d >> 24) & 255;
            int dg = (d >> 16) & 255;
            int db = (d >> 8) & 255;
            int da = d & 255;
            byte r = (byte)(((int)(((double)((dr * a) + (sr * ma))) / m)) >> 8);
            byte g = (byte)(((int)(((double)((dg * a) + (sg * ma))) / m)) >> 8);
            byte b = (byte)(((int)(((double)((db * a) + (sb * ma))) / m)) >> 8);
            byte a1 = (byte)(((int)(((double)((da * a) + (sa * ma))) / m)) >> 8);

            return
                (((r < 0) ? 0 : ((r > 255) ? 255 : r)) << 24) +
                (((g < 0) ? 0 : ((g > 255) ? 255 : g)) << 16) +
                (((b < 0) ? 0 : ((b > 255) ? 255 : b)) << 8) +
                ((a1 < 0) ? 0 : ((a1 > 255) ? 255 : a1));
        }
    }
}


